## 排序优化
排序问题融入到工作场景当中，本来单纯的外表，就会变得十分狰狞。而且，如果没有及时发现并解决，随着时间的推移，情况会愈发的糟糕。这一句话里，包含的信息颇多，我们接下来，慢慢探讨。

1. 实际工作中，一般来说，不会直接让你给一个基本类型的数组排个序；
2. 因为业务的问题，待排序列的数据类型，是多样化的，而且还有很多自定义需求；
3. 排序方法是否稳定，不再是无足轻重的了。也就意味着有可能像快排、堆排这种比较优质的排序方法不能使用，但却依然要保证高效的排序性能；
4. 没有最好的排序方法，只有更适合的。那么如何找到最适合的。
5. 如何取舍？在时间、空间上，在可维护性上等等。

所以，综合上面这几点直观的感受一下，工作中有可能你会遇到的排序优化，需要的是一个更合理、更稳定的系统性规划，而不单单是修改一下或更换个排序方法。当然了，不仅仅是排序优化，大部分的问题，都不能简单的把目光集中到当前修改的问题上。

### 

本文的安排如下：
  * 你真的掌握排序了吗
  * 优化前的预处理
  * 性能取舍

### 你真的掌握排序了？
首先说明，这个标题并不是要复杂化排序，只是作为强调而用。在多[《维视角看排序》](https://github.com/WalkingNL/C-CPP/blob/master/%E5%A4%9A%E7%BB%B4%E8%A7%86%E8%A7%92%E7%9C%8B%E6%8E%92%E5%BA%8F.md)里面，谈及了视角这个概念，这篇文章，同样从视角出发，重新梳理排序。多年前，从那篇[《快排为什么那样快》](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)的文章里，感受到同样的问题，不同的视角去审视，内心的共鸣会完全不同，最终引发的结果就是不同思考方式。而好的文章，必定具备这个特点。

#### 从快排起始
在这篇文章里，作者也不止说明了快排的快，也解释了快排的慢，以及慢的原因。所以不妨在本文中，我们就从这个角度切入。首先假设有下面的一个序列，为了排除一些非必要的干扰，确定序列中无重复的元素。随机选择一个轴元素，就记作pivot。从第一个元素开始，依次与pivot进行比较。那么A1大于或小于pivot的概率为1/2，这个都没问题，这里就假定`A1>pivot`，接下来，`A2>pivot`的概率是多少呢，答案是2/3。

    A1 A2 ... Ai ... An
如果你也看了作者的文章，会不会在这个问题上懵一下呢？懵的原因更多是对快排理解的不够彻底。还是先看看作者给出的证明吧。
> 证明：如果A2<pivot的话，那么A1，A2，pivot这三个元素之间的关系就完全确定了，即A1>pivot>A2，剩下来的元素排列的可能性我们不妨记为P（不需要具体算出来）。而如果A2>pivot的话？那么A1和A2的关系就仍然是不确定的，也就是说包含两种情况：A1>A2>pivot，以及A2>A1>pivot。对于其中任一种情况，剩下的元素排列的可能性也同样是P，于是这个分支里面剩下的排列可能性就是2P。因此当A2>pivot的时候，还剩下2/3的**可能性需要排查**

可以看出`2/3`本质上并不是指`A2>pivot`的概率，而是序列的可能性。了解这个有什么用呢？绝对不是让你记住这是快排不快的原因。所以搞清楚这个问题，也就能彻底理解了快排。快速排序的过程永远在做两件事情。
  * 找位置
  * 分类数据

代码类似下面的样子
    
    QSort(int A[], int start, int end)
    {
        ....
        int pos = partition(A, start, end);
        QSort(A, start, pos - 1);
        QSort(A, pos + 1, end);
    }

在这篇文章里，作者沿着概率的方向慢慢引导出快排之所以快的原因，核心在于每一次的排序完成之后，都能为后续元素将可能解的空间收缩一半。这句话如何理解呢？我们更为直观的解释这个问题，看下面序列，一共9个数字。未排序前，共有`9!`种重排列(如果是N个数字，就是N!)。我们选取第一个元素，即`1`作为`pivot`。第一次排完序之后，仅仅确定好了第一个位置，注意，虽然表面上序列无任何变化，但实际上，第一个位置从不确定变成了确定。那么还剩余`8!`种重排列，解空间大小减少了1/9。

    1, 6, 3, 7, 9, 5, 8, 2, 4
如果不选第一个元素为pivot，而选取第6个元素，即`5`作为pivot，进行第一次排序之后，序列变成如下。可以看到，`5`在序列的最中间，剩余`2 * 4!`种排列，解空间大小减少

    1, 3, 4, 2, 5, 6, 8, 7, 9


### 优化前的预处理

### 性能取舍

