## 错误与异常处理(现代C++)

现代C++中，多数场景下，报告及处理逻辑错误与运行时错误，优选的方式是使用异常机制。当栈中可能包含多个函数调用，而且这些函数调用处在一般用来检查错误的函数及有上下文环境知道如何处理错误的函数之间时，尤其如此。异常机制为那些用来检测错误信息，用以向上层的调用栈传递这些错误信息的代码提供了形式上有明确定义的方法。

一般来说，程序错误分两类：编程导致的**逻辑错误**及超出编程人员控制的**运行时错误**。诸如"数组越界"这样的错误，就属于前者，而**网络服务不可用**这类错误就属于后者。在C风格的编程及COM中，通过返回代表特定功能的错误码或者状态码的值，或者通过设置一个全局变量，来管理错误报告。调用者可以选择每次函数调用后，检索该全局变量，以查看是否报告错误。例如，COM编程中所使用的HRESULT返回值就是用来与调用者进行错误通信的，以及在Win32API中的GetLastError函数，用来检索最后由调用栈报告的错误。在这两个案例中，真正由调用者决定的是辨识这些返回码的值，然后对其作出适当的相应。如果调用者不能在外部处理这些错误码，程序就有可能在直接挂掉，而且不抛出任何的错误信息，或者继续伴随错误的数据运行，然后产生错误的结果。

在现代C++中，出于一下原因，应当优先使用异常处理机制：
  * 异常会强制调用代码，识别错误条件并进行处理。对未处理的异常，会阻止程序执行。
  * 异常会跳入到调用栈中，能够处理这个错误的地方。中间函数可以让异常传播，且不必与其它层进行协调。
  * 在一个异常被抛出后，根据异常机制明确定义的规则，异常stack-unwinding机制会销毁域中的所有对象。
  * 异常能够使进行错误检测的代码和处理错误的代码清晰的分离。

下面的案例呈现了C++中，抛出异常和捕获异常用到的一些必要的语法机制。

    #include <stdexcept>
    #include <limits>
    #include <iostream>

    using namespace std;

    void MyFunc(int c)
    {
        if (c > numeric_limits< char> ::max())
            throw invalid_argument("MyFunc argument too large.");
        //...
    }

    int main()
    {
        try
        {
            MyFunc(256); //cause an exception to throw
        }

        catch (invalid_argument& e)
        {
            cerr << e.what() << endl;
            return -1;
        }
        //...
        return 0;
    }
