### 内联函数
总感觉`inline`成了一个被习惯性遗忘的关键字了，在学生阶段，可能都学习过它，但真正工作之后，你真的会考虑用它吗？其实在C++语言中，内联函数的引入就是出于对性能的考虑。所以如果要编写出高性能的C++程序，在语言特性层面上，是有必要仔细分析如何才能充分发挥内联的效能。

在本节，我们将会搞清楚以下几个问题：
1. 内联函数是什么？
2. 内联VS宏替换，谁是宠儿？
3. 内联函数，什么时候需要？
4. main()可以内联吗？


#### 内联函数是什么
被调函数的函数体代码被整个的插入到调用处，而不再通过call语句进行调用，这就是内联函数。为什么要这样做呢？因为对函数进行调用，有固有的时间损耗(后面会详细分析)，而这种损耗在某些情况下是巨大的，所以需要内联函数。

怎样告诉编译器一个类成员函数要被内联呢？方式上，有两种，这里简单看一下就行。如下面的例子(示例来自[这里](https://docs.microsoft.com/en-us/cpp/cpp/inline-functions-cpp?view=vs-2019))。(1)显式的的定义，可以看到在类体外定义内联函数时，前面有`inline`关键字。(2)隐式的定义，当在类的里面声明成员函数的同时也给出了函数体，此时`inline`关键字可以省略。像`GetBalance()`方法。**为什么呢？为什么都要在有函数体的地方，才能定义**，往后看。
    
    // Inline_Member_Functions.cpp
    class Account
    {
    public:
        // 隐式的定义
        void SetAccount(double initial_balance) { balance = initial_balance; }
        double GetBalance();
        double Deposit( double Amount );
        double Withdraw( double Amount );
    private:
        double balance;
    };
    // 显式的定义
    double GetBalance() 
    { 
        return balance;
    }    
    inline double Account::Deposit( double Amount )
    {
        return ( balance += Amount );
    }

    inline double Account::Withdraw( double Amount )
    {
        return ( balance -= Amount );
    }
    int main()
    {
    }

###### 编译单元(compilation unit)与ODR原则
C++的编译是以`编译单元`为单位进行编译的，一个编译单元的大小大致和一个`.cpp`文件相当。我们知道，C++在进行编译前，还有个预处理阶段，在这个阶段，预处理会把头文件的内容完整的拷贝到`.cpp`文件的相应位置，如果有宏，还要进行宏展开等操作。等到预处理阶段真正完毕之后，编译才开始。在编译某个编译单元时，其中若有内联函数的调用，那么内联函数体必须在编译单元内。因为如果不在其中，就无法完成对调用处代码进行替代。若存在多个编译单元用到一个内联函数，按照C++规范的要求，其中的内联函数定义必须完全一致，这就是ODR(one definition rule)原则。所以，结合代码的可维护性考虑，最好将内联函数定义在头文件中，这样一来，各个编译单元中只要包含对该内联函数的`.h`文件就OK。讨论这些，只是一种建议和提醒，如果能在编码阶段就完全考虑好，后续维护起来会容易很多。

接下来，我们分析案例。如下：

    #include "account.h"

    void func()
    {
        Account a;
        a.SetAccount(100.0);
        cout << a.GetBalance();
        ......
    }
首先，进入func()时，在其栈帧中开辟空间用以存放对象a。等到进入到函数体里面，完成对对象a的构造，注意这里会调用Account默认的构造函数。然后将100.0进行压栈(因为接下来要调用函数SetAccount())，调用SetAccount函数，开辟SetAccount()函数自己的栈帧，返回时在销毁。完了之后再调用GetBlance()函数，把该函数的返回值压栈。到最后调用`cout`的`<<`操作符输出压栈的结果。这是没有内联的情况，下面看看如果内联呢，会有什么不同？

    #include "account.h"

    void func()
    {
        Account a;
        // a.SetAccount(100.0);
        a.balance = 100.0;
        
        // cout << a.GetBalance() << endl;
        double tmp = a.balance;
        cout << tmp;
        ......
    }
以上代码就是内联之后的情形，怎么样，是不是很酷！节省了函数调用必须的参数压栈、开辟栈帧及之后的各种销毁等。而且，结合代码编译器还能继续优化。如下面的代码，因为func()的终极目的就是输出设置的值，而内联就有可能让我们达到这样的目的。

    #include "account.h"

    void func()
    {
        // Account a;
        // a.SetAccount(100.0);
        // a.balance = 100.0;
        // cout << a.GetBalance() << endl;
        // double tmp = a.balance;
        cout << 100.0;
        ......
    }
当然了，这种情况属于极致的优化效果了。能达到这样的效果，是因为编译器知道足够多的上下文信息。所以，到这里，可以总结下内联函数的优点了。
1. 减少函数调用引起的开销。
2. 因为把函数体代码替换过来之后，编译器知道的上下文信息更多，分析的会更彻底。

对于第1点，函数调用时都有哪些开销呢？前面已经提到了几个，下面我们更为全面的学习一下。看下面的代码：

    void func_main()
    {
        int i = func_ord(a, b, c); // (1)
        ......                     // (2)
    }
当调用func_ord()之前，func_main()会做哪些操作呢？
> 首先，参数压栈，上面的a、b、c。如果它们是对象，还有拷贝构造的操作；
然后是保存返回地址，当函数调用结束后，要从哪里开始执行；
此外，还需要维护好当前函数栈帧中的一些寄存器信息，如堆栈指针和栈帧指针这些的。还有其他与平台相关的寄存器信息；
最后还有一些通用寄存器内容，因为通用寄存器不会区分调用者与被调用者，这有点类似全局的变量。进入被调函数后，有可能被修改，以致调用函数中的信息被覆盖。因此还需要保存它们。

上面这些工作做完了，才会调用func_ord()函数。这里需要说明两点
> 其一，首先通过移动栈指针为func_ord()函数内部声明的局部变量分配所需要的空间；其二，执行函数体内，即func_ord()内部的代码。

等到func_ord()函数执行完毕，返回时候，做的后续处理有以下几点：
> 要恢复通用寄存器的内容；恢复调用前保存的func_main()函数栈帧中的相关寄存器的内容；移动栈指针，收回func_ord()函数的栈帧；将前面保存的返回地址出栈，赋给IP寄存器；最后是移动栈指针，回收给予func_ord()函数的参数占去的空间。值得一提的是，如果入参以值传递的方式传的并且返回的是对象时，还包含对象的构造析构。如果真的是这样，调用函数会带来更大的开销。

###### 分析

C语言支持内联函数的特性吗？答案是支持。只是在声明上有点区别，`inline`关键字只能用在C++中，不过这个关键字还有两个变体，分别是`__inline`与`__forceinline`，它俩C和C++语言都支持。至于它们的区别其实也不大，我们放在后面说吧。



将被调用内联函数的函数题代码直接替代对该内联函数的调用
