### 临时对象

##### 对象作为函数的返回值
上一篇的最后，提到说如何规避返回值为对象时产生的临时对象。本篇一开始，就接着这个继续往下说。为方便，我再把前面的例子搬过来。
    
    #include <iostream>
    
    class A
    {
        friend const A operator+(const A&, const A&);
      public:
        A (int a = 0, int b = 1) : m(a), b(b)
        {
            cout << "A::A(int, int)" << endl;
        }
        A (const A& r) : m(r.m), n(r.n)
        {
            cout << "A::A(const A&)" << endl;
        }
        A& operator=(const A& r)
        {
            if (this == &r)
                return (*this);
            m = r.m;
            n = r.n;
            cout << "A::operator=(const A&)" << endl;
            return (*this);
        }
    
    private:
        int m;
        int n;
    };
    
    const A operator+(const A& a, const A& b)
    {
        cout << "operator+() start" << endl;
        A tmp; //-----------(3)------------
        tmp.m = a.m + b.n;
        tmp.n = a.n + b.;
        cout << "operator+() end" << endl;
        return tmp; //-----------(4)------------
    }
    
    int main(int argc, char* argv[])
    {
        A r, a(10, 10), b(5, 0) //-----------(1)------------
        r = a + b; //-----------(2)------------
        
        return 0;
    }
执行到(2)时，调用`+`重载函数。注意这个时候会在main()函数的栈帧中开辟一块空间，大小就是一个类A对象占用的空间。开辟这个空间的作用是存放(4)处的返回值的。上一篇有说过，因为tmp是临时变量，`+`重载函数被执行完毕之后，要被销毁的。所以在销毁前，首先会将tmp的实例空间拷贝构造一份，生成类A的一个临时对象放在main()开辟的栈帧空间中。然后在执行(2)处代码的`=`部分。这段话里有几个点，需要特别小心，我再重述以下，见下。

    语句：r = a + b;
    (1) 首先执行+运算符重载函数
    (2) 在main()中开辟空间，为了存放返回的临时对象。注意是在调用者中开辟，即main()中开辟，非被调用者。
    (3) 调用拷贝构造，生成临时对象
    (4) 执行赋值运算符
这个过程，输出如下：

    A::A(int, int) // (1)处代码的输出
    A::A(int, int) // (1)处代码的输出
    A::A(int, int) // (1)处代码的输出
    operator+() start // (2)处代码的输出，执行运算符+的重载函数
    A::A(int, int) // (3)处代码的输出，因为要构造临时变量 tmp
    operator+() end // +的重载函数
    A::A(const A&) // (4)处代码的输出
    A::operator=(const A&) // (2)处代码的输出，因为需要执行=运算符的重载函数
有个问题，我相信每一个人都遇到过。就是声明的类A的`r`对象。是否有想过对于非built-in类型的变量来说，还是先看下面的代码吧。这两种情况有什么不同呢？除了代码的表现形式之外，实际执行起来会有差别吗？

    // 第一种情况
    A r, a(10, 10), b(5, 0); 
    r = a + b;
    
    // 第二种情况
    A a(10, 10), b(5, 0);
    A r = a + b;
第一种情况，上面的结果已经有了，那么第二种情况呢，看我下面的执行结果。是的，比第一种情况，少执行了一次构造函数以及执行运算符`=`的重载函数。为了更为直观，我用下面的方式呈现执行结果。这是为什么呢？变成`A r = a + b`之后，r对象就不用执行构造函数啦？赋值运算符`=`的重载函数都不调用啦？

  ~~A::A(int, int)~~
  
  A::A(int, int)
  
  A::A(int, int)
  
  operator+() start
  
  A::A(int, int)
  
  operator+() end
  
  A::A(const A&)
  
  ~~A::operator=(const A&)~~

首先看下赋值运算符`=`。编译器对其有两种解释，下面两点。第一点，作`初始化`用，这里即是对对象`r`用`a + b`的返回结果进行初始化，并非赋值(我在想是否有人会认为初始化就是初始化呢？)。OK，那这样的区分有什么意义呢？意义就是如果是赋值，就要在main()的栈帧中开辟空间(上面的内容)，但初始化，就不用开辟这个空间的。嗯，感觉还是不对劲儿呀？就算赋值与初始化不同，但`a + b`总归不变吧。既然被编译器解释为初始化之后，不再在main()中开辟空间了，那返回的临时对象如何处理呢，总该有个接应的点吧。这是当然的，如果是赋值，接应点就是在main()中开辟的空间。如果是初始化，接应点就是r的`预留空间`。有什么区别呢？就是在`a + b`的结果返回时，将tmp作为参数调用拷贝构造函数，然后**直接**对r进行初始化。这就意味着，这种情况并没有临时对象这个中间结果的生成。
  * 作初始化用
  * 作赋值使用

到此这一点就解释完了，这能带来怎样的启发呢？我认为至少有这么一条，就是对于对象类型，尽量采用初始化，减少赋值。有些书上，给这个起了一个文绉绉的名字，叫对象延迟。通过这样的策略，减少临时对象的生成。

还能再改点什么吗？？我的意思是既然可以把`A r; r = a + b`改为`A r = a + b`。上面代码中是否有遗漏的地方呢？自然就会发现还有个tmp，我们的代码目前是这么写的`A tmp; ...; return tmp;`。若是把对象的声明等操作全部去掉，直接进行返回，改成`return A(a.m + b.m, a.n + b.n)`。效果会怎样？很明显至少会少去一个对tmp执行构造函数的过程。还有吗？上面已经分析了，`A r = a + b`中的运算符`=`被解释为初始化，所以main()函数栈帧中，对r有一个预留空间。故，在执行`return A(a.m + b.m, a.n + b.n)`时，是直接在r的预留空间中进行的。下面是代码及输出结果。

    const A operator+(const A& a, const A& b)
    {
        cout << "operator+() start" << endl;
        return A(a.m + b.m, a.n + b.n);; //-----------(2)------------
    }
    
    int main(int argc, char* argv[])
    {
        A a(10, 10), b(5, 0);
        A r = a + b; //-----------(1)------------
        
        return 0;
    }

  ~~A::A(int, int)~~
  
  A::A(int, int)
  
  A::A(int, int)
  
  operator+() start
  
  A::A(int, int)
  
  ~~operator+() end~~
  
  ~~A::A(const A&)~~
  
  ~~A::operator=(const A&)~~
  
  ##### 可能产生临时对象的其它场景
  ###### 那些糟糕的习惯
  如果未作特殊说明，下面所列举的对象，其类型都是类A的。我总觉得built-in类型的变量，培养了很多程序员糟糕的编码习惯。如果程序员之间，编码风格、习惯有差异也或许说的过去。但同一个人，如果写的代码，一会儿这样儿，一会儿那样，我真的觉得这不能接受。好吧，这个还是以后另说吧。看看下面的代码，你习惯怎样写？有些人(1)，(2)都习惯，所以审核代码时，还得忍受这些。我们知道如果是内置类型的，抛去风格差异之外，你不会在意哪种写法性能的好坏。但如果面对的是对象，就别太任性。
  
        A a(10, 10), b(5, 0);
        a = a + b;  // (1)
        a += b;     // (2)
        a -= b;
        a *= b;     // (3)
        a /= b;
 试着分别写一个对`+`运算符及`+=`运算符的重载函数。其实高下立见，对`+=`的重载不会产生临时对象，但对`+`就**不一定**了(注意这里)。所以像上述(1),(2)这样的情形，尽量采用(2)。同理，对于其它类似的情况，如`-=, *=, /=`也应该如此。
 
    // 对`+`重载
    const A operator+ (const A& a, const A& b)
    {
        return A(a.m + b.m, a.n + b.n);
    }
    
    // 对`+=`重载
    A& operator+= (const A& a)
    {
        m += a.m;
        n += a.n;
        return (*this);
    }
    
    A& operator*= (const A& a)
    {
        m *= a.m;
        n *= a.n;
        return (*this);
    }

此外，还有自增/减运算符。在built-in的情况下，`int i = 0; i++或者++i`，都知道无论前置还是后置，都会导致`i`增加1。所以两者有相同的语义场景，但两者也是不同的。对于类对象来说，要根据实际情况，重载前置和后置的情况。

    const A& operator++ () //前置，无形参
    {
        ++m;
        ++n;
        return (*this);
    }
    
    const A operator++ (int) //带一个形参 
    {
        A tmp(*this);
        ++(*this);
        return tmp; //临时变量
    }
可以看到，后置的情况，存在返回一个对象的情况，这就有可能出现临时对象。基于此，可以在不是必须使用后置的情况下，尽量使用前置。同样(--)的情况也类似。

到此，关于临时对象的讨论基本上就结束了。就个人经历来说，注意，是我跟人的经历，很少有人去关注这个。尤其新入职的，校招进来的这种情况最为明显。很多时候，他们不是故意的，只是因为临时对象的隐式属性，导致它很容易被忽视。如果时间一长，大家都不注意，很可能这个潜藏的问题就越来越多。那个时候，怕是真的就知道这种问题的可怕了。

### 后记
洋洋洒洒的写了也不少了，就这么一个点。把我工作中实际改到过的问题已经全部纳含在进去了。当然了，因为我们的编译环境比较老，像C++11以及之后的一些高级属性，还不支持。我也就没往这里加，我觉得专门的话题就到专门的地方去讨论。


