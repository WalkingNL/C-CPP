### 临时对象

##### 对象作为函数的返回值
上一篇的最后，提到说如何规避返回值为对象时产生的临时对象。本篇一开始，就接着这个继续往下说。
    
    #include <iostream>
    
    class A
    {
        friend const A operator+(const A&, const A&);
      public:
        A (int a = 0, int b = 1) : m(a), b(b)
        {
            cout << "A::A(int, int)" << endl;
        }
        A (const A& r) : m(r.m), n(r.n)
        {
            cout << "A::A(const A&)" << endl;
        }
        A& operator=(const A& r)
        {
            if (this == &r)
                return (*this);
            m = r.m;
            n = r.n;
            cout << "A::operator=(const A&)" << endl;
            return (*this);
        }
    
    private:
        int m;
        int n;
    };
    
    const A operator+(const A& a, const A& b)
    {
        cout << "operator+() start" << endl;
        A tmp; //-----------(3)------------
        tmp.m = a.m + b.n;
        tmp.n = a.n + b.;
        cout << "operator+() end" << endl;
        return tmp; //-----------(4)------------
    }
    
    int main(int argc, char* argv[])
    {
        A r, a(10, 10), b(5, 0) //-----------(1)------------
        r = a + b; //-----------(2)------------
        
        return 0;
    }
执行到(2)时，调用`+`重载函数。注意这个时候会在main()函数的栈帧中开辟一块空间，大小就是一个类A对象占用的空间。开辟这个空间的作用是存放(4)处的返回值的。上一篇有说过，因为tmp是临时变量，`+`重载函数被执行完毕之后，要被销毁的。所以在销毁前，首先会将tmp的实例空间拷贝构造一份，生成类A的一个临时对象放在main()开辟的栈帧空间中。然后在执行(2)处代码的`=`部分。这段话里有几个点，需要特别小心，我再重述以下，见下。

    语句：r = a + b;
    (1) 首先执行+运算符重载函数
    (2) 在main()中开辟空间，为了存放返回的临时对象。注意是在调用者中开辟，即main()中开辟，非被调用者。
    (3) 调用拷贝构造，生成临时对象
    (4) 执行赋值运算符
这个过程，输出如下：

    A::A(int, int) // (1)处代码的输出
    A::A(int, int) // (1)处代码的输出
    A::A(int, int) // (1)处代码的输出
    operator+() start // (2)处代码的输出，执行运算符+的重载函数
    A::A(int, int) // (3)处代码的输出，因为要构造临时变量 tmp
    operator+() end // +的重载函数
    A::A(const A&) // (4)处代码的输出
    A::operator=(const A&) // (2)处代码的输出，因为需要执行=运算符的重载函数
有个问题，我相信每一个人都遇到过。就是声明的类A的`r`对象。是否有想过对于非built-in类型的变量来说，还是先看下面的代码吧。这两种情况有什么不同呢？除了代码的表现形式之外，实际执行起来会有差别吗？

    // 第一种情况
    A r, a(10, 10), b(5, 0); 
    r = a + b;
    
    // 第二种情况
    A a(10, 10), b(5, 0);
    A r = a + b;
第一种情况，上面的结果已经有了，那么第二种情况呢，看我下面的执行结果。是的，比第一种情况，少执行了一次构造函数以及执行运算符`=`的重载函数。为了更为直观，我用下面的方式呈现执行结果。这是为什么呢？变成`A r = a + b`之后，r对象就不用执行构造函数啦？赋值运算符`=`的重载函数都不调用啦？

  ~~A::A(int, int)~~
  
  A::A(int, int)
  
  A::A(int, int)
  
  operator+() start
  
  A::A(int, int)
  
  operator+() end
  
  A::A(const A&)
  
  ~~A::operator=(const A&)~~

首先看下赋值运算符`=`。编译器对其有两种解释，下面两点。第一点，作`初始化`用，这里即是对对象`r`用`a + b`的返回结果进行初始化，并非赋值(我在想是否有人会认为初始化就是初始化呢？)。OK，那这样的区分有什么意义呢？意义就是如果是赋值，就要在main()的栈帧中开辟空间(上面的内容)，但初始化，就不用开辟这个空间的。嗯，感觉还是不对劲儿呀？就算赋值与初始化不同，但`a + b`总归不变吧。既然被编译器解释为初始化之后，不再在main()中开辟空间了，那返回的临时对象如何处理呢，总该有个接应的点吧。这是当然的，如果是赋值，接应点就是在main()中开辟的空间。如果是初始化，接应点就是r的`预留空间`。有什么区别呢？就是在`a + b`的结果返回时，将tmp作为参数调用拷贝构造函数，然后**直接**对r进行初始化。这就意味着，这种情况并没有临时对象这个中间结果的生成。
  * 作初始化用
  * 作赋值使用

到此这一点就解释完了，这能带来怎样的启发呢？我认为至少有这么一条，就是对于对象类型，尽量采用初始化，减少赋值。有些书上，给这个起了一个文绉绉的名字，叫对象延迟。通过这样的策略，减少临时对象的生成。
