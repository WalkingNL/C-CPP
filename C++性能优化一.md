## 前言
今年一直在对我们系统前后台的代码及性能做优化，感受颇深。很多时候写代码，特别容易忽略掉那些看不见的东西。本文的目标是探讨C++中那些看不见的东西之一——**临时对象**。
## 临时对象
在解释临时对象之前，先看看临时对象对性能有怎样的影响。

### 临时对象对性能的影响
对象的创建与销毁对程序性能的影响很大，尤其体积比较大的对象。比如处在复杂继承体系末端的类，或者包含很多成员变量的类。创建它们的对象，对性能影响更为显著。实际开发中，如果对这些视而不见，常常选择性的忽略，为了完成开发任务，不顾后果的任性使用，后果就是带来一大堆可见与不可见的问题。这里的"可见"与"不可见"标的都是对象。可见的对象创建与销毁，如果影响到性能，发现起来，可能相对容易很多。但是不可见的对象，由于并不会显示的体现在源码中，由编译器在编译过程中自动创建及销毁。这种"偷偷摸摸"的做法，也会影响到性能。

虽然是编译器自己产生的临时对象，但问题本身还是出在我们自己身上。先看一段代码(代码来自网络，为了说明问题而已)。可以运行输出一下，结果可能和你想象的不太一样。需要注意的是，编译环境中都开启了编译优化。所以为了看清楚效果，编译时设置编译选项`-fno-elide-constructors`，以关闭掉编译优化。
    
    #include <iostream>
    using namespace std;

    int g_constructCount=0;
    int g_copyConstructCount=0;
    int g_destructCount=0;
    struct A
    {
        A(){
            cout<<"construct: "<<++g_constructCount<<endl;    
        }

        A(const A& a)
        {
            cout<<"copy construct: "<<++g_copyConstructCount <<endl;
        }
        ~A()
        {
            cout<<"destruct: "<<++g_destructCount<<endl;
        }
    };

    A GetA()
    {
        return A();
    }

    int main() {
        A a = GetA();
        return 0;
    }

不管感觉如何，都接着往下走。我们仔细的了解学习临时对象。

### 什么是临时对象，如何产生
其实有了上面的例子，相信哪怕真的第一次听到临时对象这么个东西的人，也不会将其与临时变量混为一谈的，对吧！不过约定俗成的叫法，可能会导致一些误解，尤其对于第一次听说临时变量这个概念的人。所以，稍作解释，看下面的代码(上面代码的GetA()函数)。习惯上把整形变量`tmp_var`，也叫做一个临时变量，对吧。但是相信没人把对象`aa`称为临时对象的。我们倒是可以把它们分别称为局部变量`tmp_var`和局部对象`aa`。所以既然这种方式定义的不是临时对象，那么到底什么是临时对象？

    A GetA()
    {
        int tmp_var;
        A aa;
        
        return A();
    }

在前面就已经提到，临时对象不存在于源码中，由编译器自动产生。那么好，我们详细分析一个事例，从而掌握它。

    #include <iostream>
    #include <cstring>
    using namespace std;
    
    class Matrix
    {
    public:
        Matrix(double d = 1.0)
        {   
            cout << "Matrix::Matrix()" << endl;
            
            for (int i = 0; i < 10; i++)
            {
                for (int j = 0; j < 10; j++)
                    m[i][j] = d;
            }
        }
        Matrix(const Matrix& mt)
        {
            cout << "Matrix::Matrix(const Matrix&)" << endl;
            memcpy(this, &mt, sizeof(Matrix));
        }
        Matrix& operator=(const Matrix& mt)
        {
            if (this == &mt)
                return *this;
            
            cout << "Matrix::operator=(const Matrix)" << endl;
            memcpy(this, &mt, sizeof(Matrix));
            
            return *this;
        }
        
        friend const Matrix operator+(const Matrix&, const Matrix&);
        
    private:
        double m[10][10];
    };
    
    const Matrix operator+(const Matrix& arg1, const Matrix& arg2)
    {
        Matrix sum; //--------------(1)--------------
        for (int i = 0; i < 10; i++)
        {
            for (int j = 0; j < 10; j++)
                sum.m[i][j] = arg1.m[i][j] + arg2.m[i][j];
        }
        
        return sum; //--------------(2)--------------
    }
    
    int main()
    {
        Matrix a(2.0), b(3.0), c; //--------------(3)--------------
        c = a + b; //--------------(4)--------------
        
        return 0;
    }
###### 分析代码
在(3)处产生3个Matrix对象，会调用3次Matrix构造；在(4)处因为运算符`+`重载，执行到(1)，再调用一次Matrix构造。返回到主函数后，因为`c = a + b`，还会执行对`=`的重载函数。所以猜测执行结果如下：

    Matrix::Matrix()
    Matrix::Matrix()
    Matrix::Matrix()
    Matrix::Matrix()
    Matrix::operator=(const Matrix)
包含四次构造，一次对运算符`=`的重载。编译运行后，实际的运行结果呢？如下所示。多了一次拷贝构造的执行。一般而言，拷贝构造函数的调用不应该是，如`Matrix m = a`，类似这样的形式吗？但是代码中，除了`c = a + b`，因为运算符`=`的存在，貌似可能执行拷贝构造，就再没有任何代码了。不过，上文已经明确，这里调用的是对运算符`=`的重载函数。如果细心推测，就不难发现拷贝构造的执行一定在代码(1)之后的某条语句。那么就只有(2)了。当然，一定不是(1)(2)之间的循环。

    Matrix::Matrix()
    Matrix::Matrix()
    Matrix::Matrix()
    Matrix::Matrix()
    Matrix::Matrix(const Matrix&)
    Matrix::operator=(const Matrix)
代码(2)处表示将对象sum返回。对，就是在返回这个对象时，编译器生成了一个"临时对象"。why？这个问题就在于sum是一个临时变量，生命周期要结束了，意味着sum要被销毁了。所以返回的对象就得在当前函数的栈中开辟空间用来存放返回值。这个临时的Matrix对象就是`a + b`返回时通过拷贝构造函数构造。

###### 临时对象的产生
上面已经提及了，函数返回值为一个对象时，会产生临时对象，这只是一种情况；还有另一种情况就是函数调用时，实参类型与函数定义中的参数类型不一致。对于第二种情况解释起来，稍微要麻烦一些。不过没有关系，我们一步步来。看下面例子

    class A
    {
    public:
        A (int x = 0, int y = 1) : m(x), n(y) {} // ----------(1)-----------
    private:
        int m;
        int n;
    };
    ......
    void func()
    {
        A a; 
        a = 19; //----------(2)-----------
        ......
    }
在这种情况下，当执行到(2)的时候，会发生什么呢？可以看到，类A中并没有如前例那样，对运算符`=`进行重载，那么直接将整型值付给对象，肯定要报错的吧？但事实上，并没有。我们看看当执行到此的时候，编译器都做了什么工作？
  * 编译器合成operator=(const A& r);
  * 然后进行[bitwise copy](https://social.msdn.microsoft.com/Forums/vstudio/en-US/791dc8a1-ada1-4490-85fe-6912d4fe3734/bitwise-copy-vs-memberwise-copy)，就是逐位拷贝。
  
嗯？还是不对的，因为10是个整型值，不应该合成`operator=(int r)`这样的重载函数吗？所以这得依赖我们强大的编译器本身。在真正报错之前，编译器总是会尽可能的查找合适的转换路径，从而保证尽量的满足编译要求。所以，在这理，编译器会发现类A中有一个像(1)这样的构造函数。它会首先将19通过调用A::A(19, 1)生成一个`临时对象`，然后再调用自己合成的operator=(A& r)赋值函数，完成对对象a进行赋值。当(2)处的语句执行后，a对象内部m是100，n是1。

可以看到，私底下编译器有时候多么的"人性化"。为了做到尽可能，自己会合成辅助函数，像上面的对`=`的重载；又自己先产生临时对象，助攻我们对对象a的赋值操作。所以总结下来，上面的例子中，编译器所做的工作有
  * 合成对`=`运算符的重载
  * 类型转换。通过产生中间结果，即临时对象，完成将整型值转化为A的对象类型。

编译器悄悄做的这些工作，对于开发本身而言，简化了coding的复杂度，从而提高了开发速度。但对于性能而言，这会是一个拖累。因为对象的产生和销毁从来都不是免费的午餐。更何况像上面的例子中还牵涉类型转化，编译器还得生成额外的代码等。OK，那既然这么说，又产生新的问题了。首先，编译器为啥要做这种吃力不讨好的事情呢？其次，我们意识到这样不好，就得阻止这种事情的发生。那么如何阻止？最后就是全部交给人来做，就一定好吗？

还是那句话，我们一个一个来。我的领导也常说，发现问题本身比解决更重要，当然了，不是说解决问题就不重要。眼看着，本小节的篇幅也够长了，不妨到此先回顾下这个小结开始交代的，临时变量产生的两种场景：
1. 返回值为一个对象时；
2. 调用函数实际传入的参数与函数定义中声明的变量类型不匹配时。(注意理解这一点)。

接下来，我们看下如何规避掉编译器的好心做坏事，让它听从指挥。

### 如何规避临时对象
不管怎样我们总是希望代码由我们自己掌控，我们不希望失控。上面一节我们提到因为参数类型不匹配，编译器会产生中间对象，即临时对象，来保证看似不能正常编译的代码，依然能被正常编译。我们要阻止这样的事情发生。解决方法就是添加关键字`explicit`，如下。如此一来，再执行到上例的(2)处时，便会报错。因为添加这个关键字之后，意味着无法**隐式的调用**构造函数`A::A(int x = 0, int y = 1)`了。类似临时对象这种`偷偷摸摸`的做法，不再被允许。

    class A
    {
    public:
        explicit A (int x = 0, int y = 1) : m(x), n(y) {} // ----------(1)-----------
    private:
        int m;
        int n;
    };
 
这只是规避了产生临时对象，我们的问题没有解决的。因为我们最终希望执行(2)处的代码`a = 19`时，不需要编译器的协助，也能通过。这也好办，自己提供对运算符`=`的重载函数就OK，如下。看到，重载函数接受一个整型参数。

    public:
        A& operator=(int x)
        {
            m = a;
            n = 1;
            return *this;
        }

问题就这样解决了，添加了关键字`explicit`，保证了构造函数无法再被隐式调用；添加了对运算符`=`的重载，保证了`A a; a = 19`可以正常执行。

好吧，问题是解决了，但这并不代表问题讨论彻底了。(1)，只需要提供对`=`的重载不就行了，是否添加`explicit`，在我们的例子中，无关紧要的；(2)，有没有别的解决方法呢；(3)，提供了对运算符`=`的重载之后，就万事大吉了吗？

在上一小节中，我们还没有显式的提供重载函数时，编译器自己生成运算符`=`重载函数，但这个重载函数接受的参数只能是A类型的引用对象，所以编译器又根据构造函数A构造出了临时对象，然后再调用自己生成的重载函数，从而保证代码`a = 19`的正确执行。在本节中，当给构造函数加上了关键字`explicit`之后，等于切断了构造临时对象的去路，不能生成临时对象，就无法执行自己生成的运算符`=`重载函数，进而执行代码`a = 19`报错了。所以，追根溯源，还在于构造函数不能被调用导致的。那么依此，就可以产生一个思路，将一个整型值转换成A对象，再利用编译器自己产生的对`=`的重载函数。嗯，怎样操作呢？如下。这就是另一种解决方法，我们不需要显式提供重载运算符`=`的函数。

    A b(19);
    A a;
    a = b;

###### 利弊分析
就上面的两种办法，哪一个更好呢？如果我们自己提供运算符`=`重载函数，避免了临时对象，而且代码的编写及可读性也很好。而另一种办法，则是显式的产生一个对象，再利用编译器生成的对运算符`=`的重载函数。好处就是不用自己编写重载函数了。此外，我个人觉得后一种做法通用性更好。因为自己显式提供重载函数后，代码的扩展就成了问题，增加了设计上的成本。举例来说，自己提供了接受一个整型参数的对运算符`=`的重载函数函数后，就会产生下面的问题。因为`=`重载函数只能接受带有整型变量的赋值语句。如果下面的`a = b`要想编译通过，还得再提供一个可以接受一个对象的针对`=`的重载函数。如果再有其他的转化，还得提供更多的重载。

    A a;
    A b;
    a = 19; //通过
    a = b;  //不能通过。
### 后记






