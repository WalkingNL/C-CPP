## Memory pool
### 前言
在C/C++中，**malloc**函数或者**new**运算符是用来进行动态内存分配的，可能我们都知道，它们非常的耗时。但到底有多耗时，为什么这么耗时，对程序性能影响有多大，如果不亲眼见一次，真的很难相信。所以这篇文章，将介绍一个我在工作中遇到的案例，围绕这个案例，我们学 习一下内存池。

这篇文章的计划是这样的：
  * malloc/new 的不足
  * 案例的简介
  * 内存池及其种类
  * 固定内存池
  * 可变内存池
  * 多线程情况

### malloc/new、free/delete 的不足
作为C/C++程序员，肯定使用过这两个关键字，而且会经常使用。但这并不能表示你真正掌握它了。一般对于系统自带的函数，为了应付更多场景，必须考虑其通用性。`malloc`和`new`自然也不例外，在分配内存和释放内存时，需要很多的判断和处理，也就意味着**额外开销**的增加。那么**额外开销**具体有些什么呢？

首先，当系统进行内存分配时，根据请求分配的内存大小，在内部维护的内存空闲块表中，根据特定的算法，进行查找。当找到的某个内存空闲块能够满足请求的大小时，就开始进行分配。*但如果查找到的内存空闲块过大，还需要对其进行切割*。之后系统更新内存空闲块表，才算一次分配工作正式完成。

其次，与内存分配对立的就是内存的回收，也即释放内存空间。释放本质上就是把这部分内存重新加入到空闲内存块表中。如果有可能，还会把相邻的空闲块合并成较大的空闲块。

此外，这两个管理内存回收的函数还考虑了多线程的情况，也就意味着每次分配和释放内存时，都需要加锁。这加锁操作无疑也是笔额外的开销。

最后，如果频繁的进行堆内存的分配和释放，大量的内存碎片会随之产生，导致内存利用率降低，会进一步影响系统性能。

对于系统函数来说，必须要考虑更广泛的情况，做许多额外工作也是无可厚非的。但这不见得适合我们具体的业务场景，所以我们需要根据我们自身的特点，量体裁衣，制定出契合我们自身需要的解决方案，从而更多的提升程序的性能。

频繁的在堆上分配和释放内存，会导致性能损失，并且使系统中出现大量的内存碎片，降低了内存利用率，使得使用成本增加

### 案例简介
上面一个小节解释了**malloc/new、free/delete**这些内存管理函数存在的不足，这个小节将用少量的文字介绍一下我工作中遇到的一个案例。大致如下：

我们升级了后台之后，后台的性能有了大幅度提升。不过出现了一个尴尬的问题，就是我们的压测工具彻底变`傻`了。一般来说，压测工具必须告诉我们，升级前后，系统的详细性能参数报告。比如升级前，后台每秒可以处理X级数据量，对比升级后，系统每秒能够处理的数据量级数是aX(这里的数据量级数是对数据规模的描述，级数越高，代表能够处理的数据量越大。牵涉到一些公司隐私，不好直接暴露数据，意会就行)。那么这个a(a是正整数)有多大，压测工具得告诉我们。然而，没想到压测工具压不上去，简单的说，就是马力太小了。当大批数据流经压测工具的时候，压测工具内部会出现积压，而后台监控的所有线程中，有几个线程却处于间歇性空闲的状态。也就是说，后台还可以处理更多的数据，但是数据因为被卡在压测工具上，过不来。

这种情况的确出乎了大家的预料，不过值得欣慰的是，如果连压测工具都处理不过来来，说明我们之前对后台的优化，取得的成效很好。不过，成效再好，如果不清楚它的上限，是不明智的。所以这个任务也就落到了我身上，需要对压测工具进行优化。

因为压测工具归属权就是我们片区的，所以获取原始代码非常方便。仔细的察看源码后发现，代码中存在的问题有以下几个方面非常明显。至于其它小问题，就不一一罗列了，没有什么必要：
> 局部变量太多，而且部分局部变量放在了简直**要命**的位置上。如果这些变量是系统内置的，问题可能并不大。但如果它们是类的对象的话，问题就不容忽视，更何况，这种局部变量处在一个循环中。看下面的示例代码。

    class A //类A，
    {
    }
    
    void fun()
    {
        while (1) // 如果这个循环至少100 000次，
        {
            A a;  //定义也给类a的对象
            if (!b)
                break;
        }
    }

> 许多代码重叠。这个就不解释了，纯粹业务层面的优化。

> 频繁的malloc、free。我们数据前后台的交互用了特定的打包解包类，每一次交互，都要打包解包一次。代码里面为每一次的打包解包进行内存的分配和释放。                                                                                                                                          
当针对前面两点做了一些浅层的优化之后，比如第一点，思路就是把循环内的变量移到外面；第二点，代码上做了一些合并。压测工具可处理的数据平均情况下，比之前提升一倍。

但是对第三点，我把代码做了更改，就是打包解包的分配释放操作做移出函数体，作为全局变量存在，也就使得真正的内存分配与释放就只有一次。就这么个简单的更改后，压测工具每秒处理的数据量在前面两点优化的基础上，提升了4-5倍。这个效果非常的振奋人心，但事情不会这么的简单。因为当数据流到后台之后，解包时，有偶现的异常。排查之后，确认是这里的代码更改导致的，这也就解释了，第一次写这块代码的人，为什么不直接就这么干呢。也就是说，我们还是要给每一次数据交互进行新内存的分配，然后再回收。只是不能每次都用`malloc及free`。这就很容易想到内存池。

如果这个案例没有理解，也不用纠结，继续往下看。

### 内存池及其种类

#### 固定内存池

#### 可变内存池

### 多线程情况

### 后记

