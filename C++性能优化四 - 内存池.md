## Memory pool
### 前言
在C/C++中，**malloc**函数或者**new**运算符是用来进行动态内存分配的，可能我们都知道，它们非常的耗时。但到底有多耗时，为什么这么耗时，对程序性能影响有多大，如果不亲眼见一次，真的很难相信。所以这篇文章，将介绍一个我在工作中遇到的案例，围绕这个案例，我们学 习一下内存池。

这篇文章的计划是这样的：
  * malloc/new 的不足
  * 案例的简介
  * 内存池及其种类
  * 固定内存池
  * 可变内存池
  * 多线程情况

### malloc/new 的不足
作为C/C++程序员，肯定使用过这两个关键字，而且会经常使用。但这并不能表示你真正掌握它了。一般对于系统自带的函数，为了应付更多场景，必须考虑其通用性。`malloc`和`new`自然也不例外，在分配内存和释放内存时，需要很多的判断和处理，也就意味着额外开销的增加。那么他它们有哪些不足呢？

###### malloc/new
当系统接收到分配一定大小的内存请求时，首先要查找内部维护的内存空闲块表，然后按照相应的算法规则找到合适大小的空闲内存块，如果找到的空闲块太大，还需要对其进行切割处理；然后，系统再更新内存空闲块表，从而完成一次内存分配的工作。

###### free/delete
当遇到这两个关键字时，意味堆内存回收的工作。系统把释放的内存块再重新加入到空闲内存块表中，这个操作中，还有可能设计空闲块的合并。

此外，这些函数还考虑了多线程环境，加锁释放锁都需要一定开销

频繁的在堆上分配和释放内存，会导致性能损失，并且使系统中出现大量的内存碎片，降低了内存利用率，使得使用成本增加

我们升级了后台之后，效率大幅度提升。不过出现了一个尴尬的问题，就是我们的压测工具彻底变`傻`了。一般来说，压测工具必须告诉我们，升级前后，系统的性能报告。然而，没想到压测工具压不上去，简单的说，就是马力太小了。这的确出乎预料了，不过也侧面说明我们之前对后台的优化，效果很赞。但再赞，也得测出它功率的最大值，奈何压测工具现在使不上力。所以，领导让我想办法，解决掉这个问题。

### 案例简介

### 内存池及其种类

#### 固定内存池

#### 可变内存池

### 多线程情况

### 后记

