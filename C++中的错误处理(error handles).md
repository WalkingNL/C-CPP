## 错误处理
### 前言

下标越界时，vector内部抛出一个关于下标越界的异常，然后在没有任何信息。

assert通常也只能提供很有限的信息(文件，行号，以及assert的表达式)，但很多时候，这些信息是不足以理解一个bug的。

### 背景介绍

这里就出现了一个两难问题：严谨的错误处理要求不要忽视和放过任何一个错误，要么当即处理，要么转发给调用者，层层往上传播。任何被忽视的错误，都迟早会在代码接下去的执行流当中引发其他错误，这种被原始错误引发的二阶三阶错误可能看上去跟root cause一点关系都没有，造成bugfix的成本剧增，这是我们项目快速的开发步调下所承受不起的成本。


错误处理的成本


如何理解一个bug

理想的情况下，当一个bug发生的时刻，程序应该自己具备收集一切必要的信息的能力


1. Error Message本身，例如“您的下标越界啦！”少部分情况下，光是Error Message已经足够诊断。不过这往往是对于在开发的早期出现的一些简单bug，到中后期往往这类简单bug都被清除掉了，剩下的较为隐蔽的bug的诊断则需要多得多的信息。
2. Callstack。C++的异常由于性能的考虑，并不支持callstack。所以必须另想办法。
3. 错误发生地点的上下文变量的值：例如越界访问，那么越界的下标的值是多少，而被越界的容器的大小又是多少，等等。例如解析一段xml失败了，那么这段xml是什么，当前解析到哪儿，等等。例如调用Win32 API失败了，那么Win32 Error Message是什么。
4. 错误发生的环境：例如目标进程是什么。
5. 错误发生之前用户做了什么：对于输入法来说，例如错误发生之前的若干个键敲击。



-----






