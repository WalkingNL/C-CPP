## 排序
有关排序的重要性是不言而喻的，想象一下，如果我们的社会是无序的，那一切都将无法运作。当然，这里的*有序*和排序并不完全等价，但有序性的建立和许多策略及实施方法密不可分。这个话题要谈起来就大了，我们放在[《上帝也玩排序吗》](https://github.com/WalkingNL/C-CPP/blob/master/%E4%B8%8A%E5%B8%9D%E4%B9%9F%E7%8E%A9%E6%8E%92%E5%BA%8F%E5%90%97.md)里面讨论一些有趣的话题。

一个职业写代码的人，理应熟知各种通用的排序策略及适用场景。这里的*通用*就是指那些如快排、归并等排序方法。在写这篇文章之前，查阅了许多优秀的有关排序的博客，这些文章囊括起来，对于各种排序方法的分析、研究可以说细致入微，达到近乎完美的程度，至少以我的水平来看是如此。关于这些文章的地址，可以在我写的[《排序优化》](https://github.com/WalkingNL/C-CPP/blob/master/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96.md)里面看到。不过，毫无疑问，这些文章的定位就是介绍这些方法的，差别主要在于深浅。基于此，本文计划通过少量的篇幅，介绍一种不算常见的排序方法，其实这个方法是自己在工作中想出来的，为了解决特定业务场景下的排序问题。之所以介绍它，有三个原因，第一，视角；第二，简单；第三，它只有O(n)的时间复杂度。接下来，结合这三点，具体来看一下这个方法。

先脑补一个场景。假设有10个人站成一排，每个人的背上都贴着自己的年龄，现在要求按照年龄对这几个人进行排序。如果是一台计算机，会怎么做？如果是你，又会怎么做？前面也说了，职业程序员，排个序太简单了，以至于不屑一提。但是在你无数次的写排序相关的代码的时候，有没有注意到所有你用的排序方法的视角完全一样。什么是视角呢？看下面的图。有A、B两个点，B点就是计算机的视角，而A点就是你我的视角。嗯嗯，然后呢？我们能够注意到，B点在这一排人的顶端，更确切的它和这一排人处于相同的维度上，这样就造成，它只能看到离它最近的人，如果想看到下一个人，只能站在之前人的位置上，依此类推。相比之下，A点，我们人的视角，优势就十分明显。如果想看到整个队伍，在视力条件允许的情况下，只需要往后退到适当位置，便可一览众山。

![](https://github.com/WalkingNL/Pics/blob/master/sort1.jpg)

到这里为止，文中一直提到的视角的概念，就说清楚了。但问题在于说这有什么意义，计算机不就这样子吗？而且，多线程什么的各种并发机制，让计算机拥有非常强大的并发处理能力，解决这种问题，还不容易？其实，我们要真正的利用好计算机，而不能因为长期使用它，而被它同化。第一个发明排序算法的人，是为了让计算机也能去排序。而后人学习使用这样的方法时，不自主的对自身先降维，这应该不是每一个人的初衷。

#### 分析
回到问题本身，现在我们把这个问题放到一个二维的坐标系当中。其中，横坐标是下标，用来标示每一个人，在本文中没有意义。纵坐标代表年龄。这能给我们怎样的启示呢？不难发现，如果把每一个人的年龄都投影到纵坐标上，然后，只需要沿着纵坐标依次读取就行了。当然了，代码实现，需要一点技巧。这就是上面说的第二点————简单。接下来，稍微分析一下。整个排序的过程仅仅是进行坐标的转换，所以，时间复杂度是O(n)。此外，还有一个好处，它是稳定的，关于这一点，我们继续分析。

看到，在遇到第二个年龄为19的人的时候，由于位置已经被占，它只能放到下一个位置，这个时候，如果下一个位置也已经被占，需要先进行元素后移的操作，然后再插入。如下面的图示。

OK，基本上，这个方法的实现就是这么一个样子。再继续分析之前，先来确认几个点。首先，时间复杂度，上面说是O(n)，其实这是最好情况下的。第二，我们数据的特殊性，从两点来看，(1)只有10个数据，这显然太少；(2)这10个数据是个公差为1的等差数列。第三，很明显，如果数据存在相同的数据，就很有可能需要移动元素；第四，空间复杂度，从上例来看是O(n)，但都是这样吗？

#### 适用场景
也正如文章开头时提到的，这个方法是解决我们特定业务场景下的问题的。那些数据正好是公差为1的等差数列，所以刚好用的上。那公差如果不为1呢？当然可以，等比数列也可以。如果存在负数，需要转换成非负值的情况。那浮点数呢？这个后面会讨论，先提一点，需要做一个中间转化，即变成整数。

---






