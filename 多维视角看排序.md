## 排序
有关排序的重要性是不言而喻的，想象一下，如果我们的社会是无序的，那一切都将无法运作。当然，这里的*有序*和排序并不等价，但有序性的建立和许多策略及实施方法密不可分。这个话题要谈起来就大了，我们放在[《上帝也玩排序吗》](https://github.com/WalkingNL/C-CPP/blob/master/%E4%B8%8A%E5%B8%9D%E4%B9%9F%E7%8E%A9%E6%8E%92%E5%BA%8F%E5%90%97.md)里，讨论一些有趣的话题。

一个职业写代码的人，理应熟知各种通用的排序策略及适用场景。这里的*通用*就是指那些如快排、归并等排序方法。在写这篇文章之前，查阅了许多优秀的有关排序的博客，这些文章囊括起来，对于各种排序方法的分析、研究可以说细致入微，达到近乎完美的程度，至少以我的水平来看是如此。关于这些文章的地址，可以在我写的[《排序优化》](https://github.com/WalkingNL/C-CPP/blob/master/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96.md)里面看到。不过，毫无疑问，这些文章的定位就是介绍这些方法的，差别主要在于深浅。基于此，本文计划使用大量的篇幅，介绍一种不算常见的排序方法，其实这个方法是自己在工作中想出来的，为了解决特定业务场景下的排序问题。之所以介绍它，有三个原因，第一，视角；第二，简单；第三，最好的情况下，它只有O(n)的时间复杂度。接下来，结合这三点，具体来看一下这个方法。

先脑补一个场景。假设有10个人站成一排，每个人的背上都贴着自己的年龄，现在要求按照年龄对这几个人进行排序。如果是一台计算机，会怎么做？如果是你，又会怎么做？前面也说了，职业程序员，面对这样的排序问题，可能有些人都不屑一提。但是在你无数次的写排序相关的代码时，有没有注意到所有你用的排序方法的视角完全一样。什么是视角呢？看下面的图。有A、B两个点，B点就是计算机的视角，而A点就是你我的视角。嗯嗯，然后呢？我们能够注意到，B点在这一排人的顶端，更确切的它和这一排人处于相同的维度上，这样就造成，它只能看到处在队伍一方最顶端的人，如果想看到下一个人，只能依照规则走访，这里的规则就是顺序的访问。相比之下，A点，我们人的视角，优势就十分明显。如果想看到整个队伍，在视力条件允许的情况下，只需要往后退到适当位置，便可一览众山。

![](https://github.com/WalkingNL/Pics/blob/master/sort2.jpg)

到这里为止，一直提到的视角的概念，就说清楚了。但问题在于这有什么意义，计算机不就这样子吗？而且，多线程什么的各种并发机制，让计算机拥有非常强大的并发处理能力，解决这种问题，还不容易？

长期写代码的人，潜移默化中，就会被同化，我们可能特别擅长站在机器的角度考虑问题，然后解决问题。这也没什么不好，只是可能导致我们习惯性的不再去考虑更好的方法，哪怕局部更好，更多认为没必要。我想第一个发明排序算法的人，是为了让计算机也能去排序。而后人学习使用这样的方法时，会不自主的降维思考，这应该不是每一个人的初衷。

#### 简单分析
回到问题本身，现在我们把这个问题放到一个二维的坐标系当中，如下面的图示。其中，横坐标是下标，用来标示每一个人，在本文中没有意义。纵坐标代表年龄。这能给我们怎样的启示呢？不难发现，如果把每一个人的年龄都投影到y轴上，然后，只需要沿着纵坐标依次读取就行了。下面给出简单的示例代码。

![](https://github.com/WalkingNL/Pics/blob/master/sort4.jpg)

    int A[10] = {16, 19, 20, 18, 13, 11, 17, 15, 12, 14};

    int B[10]; // 转换空间
    for (int i = 0; i < 10; i++)
    {
      B[A[i] - 11] = A[i]; // 11是最小值
    }



这就是上面说的第二点————简单。接下来，稍微分析一下。整个排序的过程仅仅是进行坐标的转换，所以，时间复杂度是O(n)。此外，还有一个好处，它是稳定的，关于这一点，我们继续分析。

看到，在遇到第二个年龄为19的人的时候，由于位置已经被占，它只能放到下一个位置，这个时候，如果下一个位置也已经被占，需要先进行元素后移的操作，然后再插入。如下面的图示。

OK，基本上，这个方法的实现就是这么一个样子。是不是很简单。但问题不总是这种，现在仅仅是开始而已。

#### 优劣势及适用场景
##### 优势
有没有优势，以及优势的大小，永远都是一个相对的概念。那么这个方法和已有的众多排序方法比起来，具备哪些呢优势呢？
> 首先，时间复杂度。最好的情况下是O(n)。这类比快排、归并以及堆排序，已经有很大的诱惑力。而且事实上，这个O(n)的复杂度，很干净。比如归并，精确点的说，即使最好的情况，也需要O(NlogN + N)的复杂度，见下图所示的推算过程，更何况，它也同样需要O(n)的空间复杂度。还有堆排序，O(NlogN)的复杂度也是省去了系数之后的。就算是公认平均性能最好的快速排序，公平的来说，它最好的时间复杂度并没有比归并排序在最好的情况下要好。

> 其次，它是稳定的算法。而快排及堆排序都不具备这个特点。

> 此外，这个方法非常容易理解。个人觉得，这一点是其它排序方法不能比的。而且，如果数据允许，它的实现也极为简单。

> 最后，这个方法对我个人的启发性很大。这是比较抽象的一点，很难用一两句话说清楚。不过本篇文章将会围绕着这一点反复的谈。想象一下，如果一个方法不仅帮你解决了问题，还给了你更多思考的空间，以及尝试如何解决更多问题的策略，这难道不是个优势。我相信，没有人怀疑快排的伟大，但很多人仅仅是学会了这个方法本身，实际注入的思考并不多。
##### 劣势
正如有句话说的那样，优势有多明显，劣势就有多突出。不过，我并不打算急着给出所有关于这个方法不好的结论，因为一切还没有结束。不过，有一个劣势不得不提，就是通用性问题。从上面能够看到，我们例子中给出的数据是个公差为1的等差数列。如果满足不了这一点，就会出现很多问题。这个放在后续的讨论中。

##### 适用场景
正如文章开头时提到的，这个方法是解决我们特定业务场景下的问题的。而那部分数据正好是等差数列，所以刚好用的上。当然对于等比数列也可以。如果存在负数，需要转换成非负值的情况。那浮点数呢？这个后面会讨论，先提一点，需要做一个中间转化，即变成整数。

接下来，是对这个方法的进一步分析，涉及的东西就比较多，而且肯定不会简单。

---
###  深入分析





